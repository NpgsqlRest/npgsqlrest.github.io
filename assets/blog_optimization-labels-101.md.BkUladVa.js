import{_ as a,C as o,c as n,o as s,a5 as i,G as l}from"./chunks/framework.CgT1UzWm.js";const f=JSON.parse('{"title":"NpgsqlRest Story Told Without AI","titleTemplate":"NpgsqlRest","description":"PostgreSQL Optimization Labels 101","frontmatter":{"layout":"doc","outline":[2,3],"title":"NpgsqlRest Story Told Without AI","titleTemplate":"NpgsqlRest","description":"PostgreSQL Optimization Labels 101","badge":"human","head":[["meta",{"name":"keywords","content":"postgresql optimization volatile stable immutable"}],["meta",{"property":"og:title","content":"NpgsqlRest Story told without AI"}],["meta",{"property":"og:description","content":"PostgreSQL Optimization Labels 101"}],["meta",{"property":"og:type","content":"article"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:title","content":"PostgreSQL Optimization Labels 101"}]]},"headers":[],"relativePath":"blog/optimization-labels-101.md","filePath":"blog/optimization-labels-101.md"}'),r={name:"blog/optimization-labels-101.md"};function c(p,e,d,h,u,m){const t=o("BlogNav");return s(),n("div",null,[e[0]||(e[0]=i(`<h1 id="postgresql-optimization-labels-101" tabindex="-1">PostgreSQL Optimization Labels 101 <a class="header-anchor" href="#postgresql-optimization-labels-101" aria-label="Permalink to &quot;PostgreSQL Optimization Labels 101&quot;">​</a></h1><p class="blog-meta"><span>January 2026</span> · <span class="tag">PostgreSQL</span><span class="tag">Optimization</span><span class="tag">Function</span><span class="tag">VOLATILE</span><span class="tag">STABLE</span><span class="tag">IMMUTABLE</span></p><p><em>Originally published on <a href="https://medium.com/@vbilopav/postgresql-functions-optimization-labels-101-4f207f8ec635" target="_blank" rel="noreferrer">Medium</a></em></p><p>When creating a PostgreSQL function or procedure, you can declare many different labels that affect different aspects of your function. Some of them are optimization-oriented. Here is my 101 breakdown, because I keep forgetting them, and the best way to learn for me is to write.</p><h2 id="volatile-stable-immutable" tabindex="-1">VOLATILE / STABLE / IMMUTABLE <a class="header-anchor" href="#volatile-stable-immutable" aria-label="Permalink to &quot;VOLATILE / STABLE / IMMUTABLE&quot;">​</a></h2><p>These are mutually exclusive.</p><ul><li><p><strong><code>VOLATILE</code></strong> (the default) — might change the database and return different results for the same parameters. PostgreSQL cannot optimize these at all, and this is the default behavior.</p></li><li><p><strong><code>STABLE</code></strong> — can&#39;t change the database and will return the same results for the same parameters <em>within the same query</em>. Therefore, when called more than once in the same query, PostgreSQL will still execute this function only once, and hence the optimization.</p></li><li><p><strong><code>IMMUTABLE</code></strong> — can&#39;t change the database and will <em>always</em> return the same results for the same parameters. Like a mathematical function, always the same. Most aggressive optimization will probably be called once per unique set of parameters and then cached. These types of functions can be used in indexing, where others cannot.</p></li></ul><div class="warning custom-block"><p class="custom-block-title">Important</p><p>If a function marked <code>IMMUTABLE</code> calls a <code>STABLE</code> function, it will revert to <code>STABLE</code>. If <code>STABLE</code> calls <code>VOLATILE</code>, it will revert to <code>VOLATILE</code> automatically, regardless of what is set during creation — so check the metadata.</p></div><h2 id="parallel-unsafe-restricted-safe" tabindex="-1">PARALLEL UNSAFE / RESTRICTED / SAFE <a class="header-anchor" href="#parallel-unsafe-restricted-safe" aria-label="Permalink to &quot;PARALLEL UNSAFE / RESTRICTED / SAFE&quot;">​</a></h2><p>Sometimes the query planner will opportunistically decide that some operation will run in parallel. This won&#39;t happen on a small set, only when the planner estimates a performance benefit. In that case you may see something like this in the planner:</p><details class="code-collapsible" open><summary>code</summary><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Finalize Aggregate</span></span>
<span class="line"><span>    -&gt; Gather</span></span>
<span class="line"><span>         Workers Planned: 2</span></span>
<span class="line"><span>         Workers Launched: 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></details><ul><li><p><strong><code>PARALLEL UNSAFE</code></strong> (the default) — forces planner to ditch parallel execution. These functions change databases and perform transactions.</p></li><li><p><strong><code>PARALLEL RESTRICTED</code></strong> — restricts parallelism to the parallel group leader process. These functions can do temp tables, call cursors, and prepared statements.</p></li><li><p><strong><code>PARALLEL SAFE</code></strong> — safe to run in parallel mode without restriction, enabling the planner to do parallelism when it chooses to do so.</p></li></ul><h2 id="cost-rows" tabindex="-1">COST / ROWS <a class="header-anchor" href="#cost-rows" aria-label="Permalink to &quot;COST / ROWS&quot;">​</a></h2><h3 id="cost-default-100" tabindex="-1">COST (default: 100) <a class="header-anchor" href="#cost-default-100" aria-label="Permalink to &quot;COST (default: 100)&quot;">​</a></h3><p>The planner needs to know how much operations cost in terms of execution performance, and functions are indeed operations. PostgreSQL uses its own arbitrary measurement unit.</p><ul><li>With a <strong>lower cost</strong> (typically 1–10), the planner will not care about optimization when calling this function, and it will call it any time it damn well pleases.</li><li>With a <strong>higher cost</strong> (1000+), the planner will try to optimize calls for this function.</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Tackling this setting should be done if the query is indeed slow.</p></div><h3 id="rows-default-1000" tabindex="-1">ROWS (default: 1000) <a class="header-anchor" href="#rows-default-1000" aria-label="Permalink to &quot;ROWS (default: 1000)&quot;">​</a></h3><p>The number of rows returned is another piece of information for the planner that can be used to optimize calls and plan execution better. Therefore, this can only be used in functions that return sets (<code>SETOF</code> or <code>TABLE</code>).</p><p>A planner cannot possibly know the number of rows returned, and it will assume that it is 1000. But you can, and if you do, you can set this parameter.</p><p>The practical implications of this optimization label depend on which joining strategy the planner chooses, based on the row estimate:</p><ul><li><strong>Nested loop</strong> — a sort of database internal N+1, suitable strategy for small datasets</li><li><strong>Hashed join</strong> — when the planner decides it will make hashes first, and then use them to compare joining keys, much more efficient for larger sets than nested join</li></ul><p>In any case, this parameter only makes sense if you tend to join a function that returns sets.</p><h2 id="called-on-null-input-returns-null-on-null-input-strict" tabindex="-1">CALLED ON NULL INPUT / RETURNS NULL ON NULL INPUT / STRICT <a class="header-anchor" href="#called-on-null-input-returns-null-on-null-input-strict" aria-label="Permalink to &quot;CALLED ON NULL INPUT / RETURNS NULL ON NULL INPUT / STRICT&quot;">​</a></h2><p>If you have a function that is supposed to return <code>NULL</code> if one of the parameters is <code>NULL</code>, you can just say so by labeling it <code>RETURNS NULL ON NULL INPUT</code> or shorter <code>STRICT</code>. This tells the engine to avoid calling the function in that case — simply replace it with a <code>NULL</code> value.</p><p>Default is <code>CALLED ON NULL INPUT</code>, which is normal behavior, and it doesn&#39;t need to be stated explicitly.</p><hr><p>This concludes my short series on PostgreSQL optimization labels (some might call them hints).</p>`,28)),l(t,{"get-started":[{text:"Quick Start Guide",href:"/guide/quick-start"},{text:"Upload Annotations",href:"/annotations/upload"},{text:"Upload Configuration",href:"/config/uploads"},{text:"Code Generation",href:"/config/codegen"}]})])}const b=a(r,[["render",c]]);export{f as __pageData,b as default};
